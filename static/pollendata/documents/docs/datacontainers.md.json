{"attributes":{"path":"/home/lorenz/.julia/dev/DataLoaders/docs/datacontainers.md"},"tag":"document","children":[{"attributes":{},"tag":"h2","children":[{"mimes":{"text/plain":"Data containers"}}]},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"DataLoaders"}}]},{"mimes":{"text/plain":" supports some data containers out of the box, like arrays"}},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"and tuples of arrays"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" For large datasets that don"}},{"mimes":{"text/plain":"’"}},{"mimes":{"text/plain":"t fit into memory, however,"}},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"we need some custom logic that loads and preprocesses our data"}},{"mimes":{"text/plain":"."}}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"We can make any data container compatible with "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"DataLoaders"}}]},{"mimes":{"text/plain":" by implementing"}},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"the two methods "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"nobs"}}]},{"mimes":{"text/plain":" and "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"getobs"}}]},{"mimes":{"text/plain":" from the interface package "}},{"attributes":{"href":"https://github.com/JuliaML/LearnBase.jl","title":""},"tag":"a","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"LearnBase"}}]}]},{"mimes":{"text/plain":"."}}]},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"nobs(ds::MyDataset)"}}]},{"mimes":{"text/plain":" returns the number of observations in your data container"}},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"and "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"getobs(ds::MyDataset, idx)"}}]},{"mimes":{"text/plain":" loads a single observation"}},{"mimes":{"text/plain":"."}}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"For performance reasons, you may want to implement "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"getobs!(buf, ds::MyDataset, idx)"}}]},{"mimes":{"text/plain":", a buffered version"}},{"mimes":{"text/plain":"."}}]},{"attributes":{},"tag":"h3","children":[{"mimes":{"text/plain":"At last, a realistic example"}}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"Image datasets are a good use case for "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"DataLoaders"}}]},{"mimes":{"text/plain":" because"}}]},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"20GB (or more) of images will likely not fit into your memory, so we need an"}},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"out"}},{"mimes":{"text/plain":"-"}},{"mimes":{"text/plain":"of"}},{"mimes":{"text/plain":"-"}},{"mimes":{"text/plain":"memory solution; and"}}]}]},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"decoding images is CPU"}},{"mimes":{"text/plain":"-"}},{"mimes":{"text/plain":"bottlenecked (provided your secondary storage can keep up),"}},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"so we benefit from using multiple threads"}},{"mimes":{"text/plain":"."}}]}]}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"A simple data container might simply be a struct that contains the paths to"}},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"a lot of image files, like so:"}}]},{"attributes":{"lang":"julia"},"tag":"pre","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"struct ImageDataset\n    files::Vector{String}\nend\n"}}]}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"Since we"}},{"mimes":{"text/plain":"’"}},{"mimes":{"text/plain":"re only storing the file paths and not the actual images, "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"ImageDataset"}}]},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"barely takes up memory"}},{"mimes":{"text/plain":"."}}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"Implementing the data container interface is straightforward:"}}]},{"attributes":{"lang":"julia"},"tag":"pre","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"import LearnBase: nobs, getobs\nusing Images: load\n\nnobs(ds::ImageDataset) = length(ds.files)\ngetobs(ds::ImageDataset, idx::Int) = load(ds.files[idx])\n"}}]}]},{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"And now we can use it with "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"DataLoaders"}}]},{"mimes":{"text/plain":":"}}]},{"attributes":{"lang":"julia"},"tag":"pre","children":[{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"data = ImageDataset(readdir(\"./IMAGENET_IMAGES\"))\n\ndataloader = DataLoader(data, 32; collate = false)\n\nfor images in dataloader\n    # do your thing\nend\n"}}]}]},{"attributes":{},"tag":"admonition","children":[{"attributes":{},"tag":"p","children":[{"mimes":{"text/plain":"To use "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"DataLoaders"}}]},{"mimes":{"text/plain":"’"}},{"mimes":{"text/plain":" multi"}},{"mimes":{"text/plain":"-"}},{"mimes":{"text/plain":"threading, you need to start Julia with multiple"}},{"attributes":{},"tag":"br","children":[]},{"mimes":{"text/plain":"threads"}},{"mimes":{"text/plain":"."}},{"mimes":{"text/plain":" Check the number of available threads with "}},{"attributes":{},"tag":"code","children":[{"mimes":{"text/plain":"Threads.nthreads()"}}]},{"mimes":{"text/plain":"."}}]}]}]}