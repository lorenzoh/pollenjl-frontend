{"attributes":{"path":"/home/lorenz/.julia/dev/DataLoaders/src/batchview.jl"},"tag":"sourcefile","children":[{"mimes":{"text/plain":"abstract type BatchDim end\n\nstruct BatchDimFirst <: BatchDim end\nstruct BatchDimLast <: BatchDim end\n\n\"\"\"\n    BatchViewCollated(data, size; droplast = false)\n\nA batch view of container `data` with collated batches of\nsize `size`.\n\"\"\"\n@with_kw_noshow struct BatchViewCollated{TData}\n    data::TData\n    size::Int\n    count::Int\n    partial::Bool\n    batchdim::BatchDim = BatchDimLast()\nend\n\nBase.show(io::IO, bvcollated::BatchViewCollated) = print(io, \"batchviewcollated() with $(bvcollated.count) batches of size $(bvcollated.size)\")\n\nconst batchviewcollated = BatchViewCollated\n\nfunction BatchViewCollated(data, size; partial = true, batchdim = BatchDimLast())\n    count = nobs(data) รท size\n    if partial && (nobs(data) % size > 0)\n        count += 1\n    end\n    return BatchViewCollated(data, size, count, partial, batchdim)\nend\n\nBase.length(bv::BatchViewCollated) = bv.count\nLearnBase.nobs(bv::BatchViewCollated) = length(bv)\n\nfunction LearnBase.getobs(bv::BatchViewCollated, idx::Int)\n    idxs = batchindices(nobs(bv.data), bv.size, idx)\n    collate([getobs(bv.data, idx) for idx in idxs])\nend\n\nfunction LearnBase.getobs!(buf, bv::BatchViewCollated, idx::Int)\n    indices = batchindices(nobs(bv.data), bv.size, idx)\n    for (idx, obs) in zip(indices, obsslices(buf, bv.batchdim))\n        obs_ = getobs!(obs, bv.data, idx)\n        # if data container does not implement, getobs!, this is needed\n        if obs_ !== obs\n            copyrec!(obs, obs_)\n        end\n    end\n\n    if bv.partial && (idx == nobs(bv)) && (nobs(bv.data) % bv.size > 0)\n        # This will mess up the buffer in the `RingBuffer`\n        # by not reinserting the correct buffer.\n        # It is okay only because it will that buffer will\n        # not be used since the partial batch is the last\n        # batch.\n        return obsslice(buf, 1:(nobs(bv.data) % bv.size), bv.batchdim)\n    end\n\n\n    return buf\nend\n\n\n# batch view helpers\n\n\"\"\"\n    obsslices(batch, batchdim = BatchDimLast())\n\nIterate over views of all observations in a `batch`.\n`batch` can be a batched array, a tuple of batches, or a\ndict of batches.\n\n```julia\nbatch = rand(10, 10, 4)  # batch size is 4\niter = obsslices(batch, BatchDimLast())\n@assert size(first(iter)) == (10, 10)\n\niter2 = obsslices(batch, BatchDimFirst())\n@assert size(first(iter)) == (10, 4)\n```\n\"\"\"\nobsslices(batch, batchdim = BatchDimLast()) =\n    (obsslice(batch, i, batchdim) for i in 1:_batchsize(batch, batchdim))\n\nfunction obsslice(batch::AbstractArray{T, N}, i, ::BatchDimLast) where {T, N}\n    return view(batch, [(:) for _ in 1:N-1]..., i)\nend\n\nfunction obsslice(batch::AbstractArray{T, N}, i, ::BatchDimFirst) where {T, N}\n    return view(batch, i, [(:) for _ in 2:N]...)\nend\n\nfunction obsslice(batch::Tuple, i, batchdim)\n    return Tuple(obsslice(batch[j], i, batchdim) for j in 1:length(batch))\nend\n\nfunction obsslice(batch::NamedTuple, i, batchdim)\n    return (; zip(keys(batch), obsslice(values(batch), i, batchdim))...)\nend\n\nfunction obsslice(batch::Dict, i, batchdim)\n    return Dict(k => obsslice(v, i, batchdim) for (k, v) in batch)\nend\n\n# Utils\n\n_batchsize(batch::Tuple, batchdim) = _batchsize(batch[1], batchdim)\n_batchsize(batch::Dict, batchdim) = _batchsize(batch[first(keys(batch))], batchdim)\n_batchsize(batch::AbstractArray{T, N}, ::BatchDimLast) where {T, N} = size(batch, N)\n_batchsize(batch::AbstractArray, ::BatchDimFirst) = size(batch, 1)\n\ncopyrec!(dst::AbstractArray, src::AbstractArray) = copy!(dst, src)\ncopyrec!(dst::Tuple, src::Tuple) = foreach((a, b) -> copyrec!(a, b), dst, src)\ncopyrec!(dst::NamedTuple, src::NamedTuple) = copyrec!(values(dst), values(src))\ncopyrec!(dst::Dict, src::Dict) = foreach((a, b) -> copyrec!(dst, src), values(dst), values(src))\n\n\"\"\"\n    batchindices(n, size, i)\n\nGet the indices of batch `i` with batch size `size` of\na collection with `n` elements.\n\nMight be a partial batch if `i` is the last batch and\n`n` is not divisible by `size`.\n\"\"\"\nfunction batchindices(n, size::Int, i::Int)\n    from = (i - 1) * size + 1\n    to = min(n, from + size - 1)\n    return from:to\nend\n"}}]}