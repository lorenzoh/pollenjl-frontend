{"attributes":{"path":"/home/lorenz/.julia/dev/DataLoaders/src/loaders.jl"},"tag":"sourcefile","children":[{"mimes":{"text/plain":"\n\nstruct GetObsParallel{TData}\n    data::TData\n    useprimary::Bool\n    function GetObsParallel(data::TData; useprimary = false) where {TData}\n        (useprimary || Threads.nthreads() > 1) ||\n            error(\"Cannot load data off main thread with only one thread available. Pass `useprimary = true` or start Julia with > 1 threads.\")\n        return new{TData}(data, useprimary)\n    end\nend\n\n\nBase.length(iterparallel::GetObsParallel) = nobs(iterparallel.data)\n\nfunction Base.iterate(iterparallel::GetObsParallel)\n    resultschannel = Channel(Threads.nthreads() - Int(!iterparallel.useprimary))\n\n    workerpool =\n        WorkerPool(1:nobs(iterparallel.data), useprimary = iterparallel.useprimary) do idx\n            put!(resultschannel, getobs(iterparallel.data, idx))\n        end\n    @async run(workerpool)\n\n    return iterate(iterparallel, (resultschannel, workerpool, 0))\nend\n\n\nfunction Base.iterate(iterparallel::GetObsParallel, state)\n    resultschannel, workerpool, index = state\n\n    # Worker pool failed\n    if workerpool.state === Failed\n        error(\"Worker pool failed.\")\n        # Iteration complete\n    elseif index >= nobs(iterparallel.data)\n        return nothing\n    else\n        return take!(resultschannel), (resultschannel, workerpool, index + 1)\n    end\nend\n\n\n# Buffered version\n\n\"\"\"\n    BufferGetObsParallel(data; useprimary = false)\n\nLike `MLDataPattern.BufferGetObs` but preloads observations into a\nbuffer ring with multi-threaded workers.\n\"\"\"\nstruct BufferGetObsParallel{TElem,TData}\n    data::TData\n    buffers::Vector{TElem}\n    useprimary::Bool\nend\n\nBase.show(io::IO, bufparallel::BufferGetObsParallel) = print(io, \"eachobsparallel($(bufparallel.data))\")\n\nfunction BufferGetObsParallel(data; useprimary = false)\n    nthreads = Threads.nthreads() - Int(!useprimary)\n    nthreads > 0 ||\n        error(\"Cannot load data off main thread with only one thread available. Pass `useprimary = true` or start Julia with > 1 threads.\")\n\n    buffer = getobs(data, 1)\n    buffers = [buffer]\n    for _ âˆˆ 1:nthreads\n        push!(buffers, deepcopy(buffer))\n    end\n\n    return BufferGetObsParallel(data, buffers, useprimary)\nend\n\n\nBase.length(iterparallel::BufferGetObsParallel) = nobs(iterparallel.data)\n\n\nfunction Base.iterate(iterparallel::BufferGetObsParallel)\n    ringbuffer = RingBuffer(iterparallel.buffers)\n\n    workerpool =\n        WorkerPool(1:nobs(iterparallel.data), useprimary = iterparallel.useprimary) do idx\n            put!(ringbuffer) do buf\n                getobs!(buf, iterparallel.data, idx)\n            end\n        end\n    @async run(workerpool)\n\n    return iterate(iterparallel, (ringbuffer, workerpool, 0))\nend\n\n\nfunction Base.iterate(iterparallel::BufferGetObsParallel, state)\n    ringbuffer, workerpool, index = state\n\n    # Worker pool failed\n    if workerpool.state === Failed\n        error(\"Worker pool failed.\")\n        # Iteration complete\n    elseif index >= nobs(iterparallel.data)\n        return nothing\n    else\n        return take!(ringbuffer), (ringbuffer, workerpool, index + 1)\n    end\nend\n\n\n# functional interface\n\n\"\"\"\n    eachobsparallel(data; useprimary = false, buffered = true)\n\nParallel data iterator for data container `data`. Loads data on all\navailable threads (except the first if `useprimary` is `false`).\n\nIf `buffered` is `true`, uses `getobs!` to load samples inplace.\n\nSee also `MLDataPattern.eachobs`\n\n\n!!! warning \"Order\"\n\n    `eachobsparallel` does not guarantee that the samples\n    are returned in the correct order.\n\n\"\"\"\neachobsparallel(data; useprimary = false, buffered = true) =\n    buffered ? BufferGetObsParallel(data, useprimary = useprimary) :\n    GetObsParallel(data, useprimary = useprimary)\n"}}]}