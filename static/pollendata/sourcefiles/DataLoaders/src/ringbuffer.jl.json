{"attributes":{"path":"/home/lorenz/.julia/dev/DataLoaders/src/ringbuffer.jl"},"tag":"sourcefile","children":[{"mimes":{"text/plain":"\n\"\"\"\n    RingBuffer(size, buf)\n\nA `Channel`-like data structure that rotates through\n`size` buffers. `put!`s work by mutating one of the buffers:\n\n```\nput!(ringbuffer) do buf\n    rand!(buf)\nend\n```\n\nThe result can then be `take!`n:\n\n```\nres = take!(ringbuffer)\n```\n\n!!! warning \"Invalidation\"\n\n    Only one result is valid at a time! On the next `take!`, the previous\n    result will be reused as a buffer and be mutated by a `put!`\n\nSee also [`put!`](#)\n\"\"\"\nmutable struct RingBuffer{T}\n    buffers::Channel{T}\n    results::Channel{T}\n    current::T\nend\n\nfunction RingBuffer(bufs::Vector{T}) where T\n    size = length(bufs) - 1\n    buffers = Channel{T}(size + 1)\n    results = Channel{T}(size)\n    foreach(bufs[2:end]) do buf\n        put!(buffers, buf)\n    end\n\n    return RingBuffer{T}(buffers, results, bufs[1])\nend\n\nfunction RingBuffer(size, buffer::T) where T\n    buffers = [buffer]\n    for i ∈ 1:size\n        push!(buffers, deepcopy(buffer))\n    end\n    return RingBuffer(buffers)\nend\n\n\nfunction Base.take!(ringbuffer::RingBuffer)\n    put!(ringbuffer.buffers, ringbuffer.current)\n    ringbuffer.current = take!(ringbuffer.results)\n    return ringbuffer.current\nend\n\n\n\"\"\"\n    put!(f!, ringbuffer::RingBuffer)\n\nApply f! to a buffer in `ringbuffer` and put into the results\nchannel.\n\n```julia\nx = rand(10, 10)\nringbuffer = RingBuffer(1, x)\nput!(ringbuffer) do buf\n    @test x == buf\n    copy!(buf, rand(10, 10))\nend\nx_ = take!(ringbuffer)\n@test !(x ≈ x_)\n\n```\n\"\"\"\nfunction Base.put!(f!, ringbuffer::RingBuffer)\n    buf = take!(ringbuffer.buffers)\n    buf_ = f!(buf)\n    #@assert buf_ === buf\n    put!(ringbuffer.results, buf_)\nend\n\n\nfunction Base.close(ringbuffer::RingBuffer)\n    close(ringbuffer.results)\n    close(ringbuffer.buffers)\nend\n"}}]}