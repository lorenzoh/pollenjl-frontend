{"attributes":{"path":"/home/lorenz/.julia/dev/DataLoaders/src/workerpool.jl"},"tag":"sourcefile","children":[{"mimes":{"text/plain":"@enum PoolState begin\n    Done\n    Running\n    Failed\nend\n\nstruct PoolFailedException <: Exception\n    s::Any\nend\n\nmutable struct WorkerPool{TArgs}\n    workerfn::Any\n    args::Vector{TArgs}\n    useprimary::Bool\n    state::PoolState\n    ntasks::Threads.Atomic{Int}\nend\n\n\nfunction WorkerPool(workerfn, args::AbstractVector{TArgs}; useprimary = false) where {TArgs}\n    (useprimary || Threads.nthreads() > 1) ||\n        error(\"Cannot load data off main thread with only one thread available. Pass `useprimary = true` or start Julia with >1 threads.\")\n    return WorkerPool{TArgs}(workerfn, collect(args), useprimary, Done, Threads.Atomic{Int}(0))\nend\n\n\nfunction run(pool::WorkerPool)\n    pool.state = Running\n    # set remaining tasks counter.\n    pool.ntasks[] = length(pool.args)\n\n    # watchdog that sends exception to main thread if a worker fails\n    maintask = current_task()\n    @async begin\n        while pool.state !== Done\n            if pool.state === Failed\n                Base.throwto(\n                    maintask,\n                    PoolFailedException(\"Failed to process all tasks. $(pool.ntasks[]) unfinished tasks remaining\"),\n                )\n            end\n            sleep(0.1)\n        end\n    end\n\n    function inloop(args)\n        #for args in pool.args  # uncomment for debugging\n        # task error handling\n        pool.state !== Failed || error(\"Shutting down worker $(Threads.threadid())\")\n        try\n            # execute task\n            pool.workerfn(args...)\n            Threads.atomic_add!(pool.ntasks, -1)\n        catch e\n            println(stacktrace())\n            @error \"Exception while executing task on worker $(Threads.threadid()). Shutting down WorkerPool.\" e =\n                e stacktrace = stacktrace() args = args\n            pool.state = Failed\n            rethrow()\n        end\n    end\n\n    if pool.useprimary\n        @qthreads for args in pool.args\n            inloop(args)\n        end\n    else\n        @qbthreads for args in pool.args\n            inloop(args)\n        end\n    end\n\n    # Tasks completed successfully\n    pool.state = Done\nend\n"}}]}